# Instruments
## DI
### Аттрибут [DI]
Применяется к полям, свойства и методам.
[DI] private int anyField;
[DI] private int anyProp {get; set;};
[DI] private int MethodInit(){};

При инъекции все поля и свойства будут заполнены через рефлексию. Если необходимого типа нет в DiBox будет выдана ошибка.
При инъекции будет запущен только ОДИН метод, помеченный DI. 

### Binding
  1) **DiBox.RegisterSingle<T>(T instance, string id = "")**
  Региструет объект как синголтон по типу который передан в T. Если тип не передан, то региструется по типу самого объекта. Если объект надо зарегистрировать как реализацию интерфейса, то в <T> надо передать интерфейс, а в "instance" уже объект, реализующий данный интерфейс.  
### ______  
  2.1) **DiBox.RemoveSingel<T>(string id = "")**
  Удаляет объект по его типу из контейнера.
  2.2) **DiBox.RemoveSingelType(Type type, string id = "")**
  Аналог 2.1, но тип передается теперь не как дженерик.
### ______  
  3.1) **DiBox.ResolveSingle<T>(string id = "")**
  Запрос из контейнера объекта по его типу через дженерик и id.
  3.2) **DiBox.ResolveSingle(Type type, string id = "")**
  Аналог 3.1, но без дженерика
### ______     
  4) **DiBox.RegisterTransit<T>(TransitMethod<T> transitMethod, string id = "")**
  Регистрация транзит метода (транзит метод будет выдывать новый объекта типа Т при обращения к нему).
  5) **DiBox.RemoveTransit<T>(string id = "")**  - удаление транзит объекта
  6) **DiBox.ResolveTransit<T>(string id = "")** - запрос транзит объекта
  
  
### Create and inject
  1) **DiBox.CreatePrefab(GameObject prefab)** - Создание префаба при помощи DiBox. При таком способе спауна, все поля и методы отмечены аттрибутом [DI] будут выполнены до Awake. Возвращается GameObject
  2) **DiBox.CreatePrefab<T>(T instance)** where T : Component - Аналог предыдущего метода, но спаун происходит через компонент и в качестве результата возращается компонент но новом объекте в сцене.
  3) **DiBox.InjectSingle(Object obj)** - метод который заполняет все поля и выполняет методы отмечены аттрибутом [DI]
  
### Scene and DI
  1) **BindDIScene** - компонент, чей Awake выполняется до Awake других объектов. Цель данного компонента зарегистрировать какое нибудь поведение на сцене в DiBox,  а так же выполнить все FactoryDI. Так же при выключение сцены в зависимости от настроек в списке объектов у BindDIScene и FactoryDI, некоторые зарегистрированных объектов могут быть удалены.
  !Внимание! Если установка прошла не через UnityPackage, вам придется самим установиться Script Execution Order для BindDIScene и InejctDI.
  2) **FactoryDI** - абстрактный класс. Если ваша логика занесения объектов в DiBox сложна и не помещается в список объектов у BindDIScene, то вам нужно создать поведение, унаследовавшись от этого класса, прописав в нём логику создания и удаления объекта из DiBox. Не забудь FactoryDI добавлять в список для фабрик в BindDIScene. BindDIScene контролиует поток создания и удаления объектов, фабрикам лишь делегируют некоторую логику.
  3) **InjectDI** - Компонент, который находит все MonoBeh на сцене и внедряет в них зависимости. Без него ничего работать не будет.

  ## PhysicShell
  Содержат обертку для триггиреров и коллайдеров для 2д и 3д пространства. Каждый компонент имеет по 3 события Enter, Stay, Exit с аргументами аналогичные для **On**(**Trigger**\**Collision**)(**Enter**\**Stay**\**Exit**)(**..**\**2D**). С этими компонентами вам не нужно гадать какой триггерв вызовет OnTriggerStay или смешивать логику поведения компонента объета и считывания события входа в коллайдер.
  
  ## LevelsStateMachine
  
  ## Sound
  ### SoundSystem
  Создание: Перед тем, как использовать эту систему вам необходимо её где-то создать и поместить в DiBox.
  1) **TurnOffAll** - выключает все звуки, управляемые этой системой.
  2) **Play(ISound2D sound)** - начинает проигрывать звук ISound2D с заднными параметрами в нем. Возвращает AudioSource для управления его положение в пространстве.
  **Внимание** - вам нельзя менять родителя о AudioSource, так как они все приклепленны к объекту, который не уничтажается при смене сцены.
  3) **Play(ISound2DLoop sound, LoopAction action,  out Transform sourceTransform)** - аналогичен первому, но для залупленных звуков. ISound2DLoop содержит свой ID, с которым и будет работать SoundSystem. В LoopAction вам нужно передать что делать со звуком (пока либо остановить, либо запустить). Так же через out вам возращается Transform сорса, который сейчас играет. Если звук уже играет, то повторно его запустить нельзя будет и out будет null. Тоже самое, если звука нет, то остановка ничего не сделает.
  ### Звуки как SO объекты
  Пока ISound2D и ISund2DLoop есть только в форме SO объектов, которые вы настраивайте в редакторе. У них есть поля Sound и Pitch, у которых есть настройка IsRandom. Если она true, то значение будет выбираться из Min и Max. Иначе будет браться Min.
  
  ## HabObject
  ## EventChanel
  
  ## SettingIData
  ## CustomizableWindow
    
  ## Interfaces
